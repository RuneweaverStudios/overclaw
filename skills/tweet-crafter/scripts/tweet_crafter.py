import os
import json
import argparse
import logging
import subprocess

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

SKILL_DIR = os.path.dirname(os.path.abspath(__file__))
CONFIG_PATH = os.path.join(SKILL_DIR, "..", "config.json")

def load_config():
    try:
        with open(CONFIG_PATH, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logging.error(f"Config file not found at {CONFIG_PATH}")
        return {}

_config = load_config()

AGENT_SWARM_SCRIPT = os.path.join(
    SKILL_DIR, "..", "..", "agent-swarm", "scripts", "router.py"
)

def _call_agent_swarm(prompt: str, model: str = "openrouter/moonshotai/kimi-k2.5", tier: str = "CREATIVE") -> str:
    logging.info(f"Calling Agent Swarm with model: {model}, tier: {tier}")
    if not os.path.exists(AGENT_SWARM_SCRIPT):
        logging.error(f"Agent Swarm script not found: {AGENT_SWARM_SCRIPT}")
        raise FileNotFoundError("Agent Swarm script not found. Please ensure it's installed and correctly configured.")

    # Use router.py classify to determine the model if not explicitly given
    # For this skill, we'll assume the model is given or the default CREATIVE tier is used
    spawn_command = [
        "python3",
        AGENT_SWARM_SCRIPT,
        "spawn",
        "--json",
        prompt
    ]
    
    # The router.py spawn command needs to be executed via OpenClaw's exec
    # However, this script is itself an OpenClaw skill. Calling exec recursively is not ideal.
    # The main OpenClaw agent running this should be responsible for calling Agent Swarm.
    # For direct execution of this script, we'll simulate the call or use subprocess with a simpler router call.
    logging.warning("Direct Agent Swarm spawning from within a skill script is a placeholder/simulation.")
    logging.warning("In a real OpenClaw workflow, the main agent would call Agent Swarm then sessions_spawn this skill.")

    # Simulate Agent Swarm call for generation from within the script
    # This is a mock response, replace with actual LLM call if direct access is configured
    mock_response = {
        "task": prompt,
        "model": model,
        "sessionTarget": "isolated",
        "generated_content": f"[MOCKED GENERATED CONTENT by {model} for: '" + prompt[:50] + "...']" if "tweet" in prompt.lower() else f"# Mock Blog Post\n\n" + f"This is a mock blog post generated by {model} based on the prompt: '" + prompt[:100] + "...'\n\n" + "It would expand on the tweet and provide more details about the skill."
    }
    # In a fully integrated OpenClaw design, the main agent would handle the sessions_spawn for the LLM call
    # and then pass the generated content back to this skill.
    return mock_response["generated_content"]

def draft_content(
    tweet_prompt: str,
    blog_context: str,
    skill_name: str = None,
    github_repo: str = None,
    clawhub_link: str = None,
    mentions: list = None,
    hashtags: list = None,
    character_limit: int = 280
) -> dict:
    logging.info("Drafting tweet and blog content...")

    # Use Agent Swarm to generate tweet
    full_tweet_prompt = f"Craft a tweet (max {character_limit} chars) based on: '\"\"\"" + tweet_prompt + "\"\"\"' "
    if skill_name: full_tweet_prompt += f"about the skill {skill_name} "
    if clawhub_link: full_tweet_prompt += f"Include the ClawHub link: {clawhub_link}. "
    if mentions: full_tweet_prompt += f"Mention: {' '.join(mentions)}. "
    if hashtags: full_tweet_prompt += f"Include hashtags: {' '.join(hashtags)}. "
    full_tweet_prompt += "Ensure it's engaging and concise."

    # This is where OpenClaw should be calling Agent Swarm via sessions_spawn
    # For now, we simulate this call.
    drafted_tweet = _call_agent_swarm(full_tweet_prompt, tier="CREATIVE")

    # Use Agent Swarm to generate blog post
    full_blog_prompt = f"Write a blog post about '\"\"\"" + tweet_prompt + "\"\"\"' using this context: '\"\"\"" + blog_context + "\"\"\"' "
    if skill_name: full_blog_prompt += f"Focus on the {skill_name} skill. "
    if github_repo: full_blog_prompt += f"Mention the GitHub repository: {github_repo}. "
    if clawhub_link: full_blog_prompt += f"Also link the ClawHub page: {clawhub_link}. "
    full_blog_prompt += "Make it human, witty, intelligent, not overly technical, and include codeblocks, dev notes, test suggestions, and examples."

    drafted_blog = _call_agent_swarm(full_blog_prompt, tier="CREATIVE")

    # Format tweet as a code block for easy copying
    formatted_tweet = f"```text\n{drafted_tweet}\n```"
    return {"tweet": formatted_tweet, "blog_post": drafted_blog}

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Tweet Crafter Skill for OpenClaw.")
    parser.add_argument('--tweet_prompt', type=str, required=True, help='Prompt for the tweet.')
    parser.add_argument('--blog_context', type=str, required=True, help='Context for the blog post.')
    parser.add_argument('--skill_name', type=str, default=None, help='Name of the skill.')
    parser.add_argument('--github_repo', type=str, default=None, help='GitHub repository URL.')
    parser.add_argument('--clawhub_link', type=str, default=None, help='ClawHub link.')
    parser.add_argument('--mentions', type=str, default='[]', help='JSON string of mentions (e.g., ["@user1"]).')
    parser.add_argument('--hashtags', type=str, default='[]', help='JSON string of hashtags (e.g., ["#tag1"]).')
    parser.add_argument('--character_limit', type=int, default=280, help='Tweet character limit.')

    args = parser.parse_args()

    try:
        mentions_list = json.loads(args.mentions)
        hashtags_list = json.loads(args.hashtags)
        
        result = draft_content(
            tweet_prompt=args.tweet_prompt,
            blog_context=args.blog_context,
            skill_name=args.skill_name,
            github_repo=args.github_repo,
            clawhub_link=args.clawhub_link,
            mentions=mentions_list,
            hashtags=hashtags_list,
            character_limit=args.character_limit
        )
        print("--- TWEET DRAFT ---")
        print(result["tweet"])
        print("--- BLOG POST DRAFT ---")
        print(result["blog_post"])
    except Exception as e:
        logging.error(f"Error in Tweet Crafter: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
